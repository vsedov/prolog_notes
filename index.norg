@document.meta
  title: index
  description:
  authors: viv
  categories:
  created: 2022-03-04
  version: 0.0.11
@end

= TOC

* Chapter 2 Uniformed Search
 ** Examples of Uniformed Search
    Uniformed search is a tree search, or the concept of how one would iterate through a given tree

    1. Breadth First Search
    2. Depth First Search
    3. Depth Limited Search
    4. Iterative Deepening Search /Sounds cool right/

 ** Tree search Algorithm

  *** Basic Information
      ^State vs Nodes^

      1. A /*State*/ is a representation of a some physicial figure.

      2. A /*Node*/ is a structure [Data Structure] Containing a search tree of the following types
      -- Parent
      -- Child
      -- Depth [ Height ]
      -- Path Cost -> g(n)
       ___
      3. A /*State*/ Does not have Parent, child, depth or path cost !!
      ___
            
         ┌──   ──┐     <- State                               ┌──────┐
         │ 5 4 _ ├────────────── <-   ┌─┬────────────────────►│Parent│ Node
         │ 6 1 8 │                    │A│ Node                └──────┘
         │ 7 3 2 │             ┌─────►└─┘◄─────┐
         └──   ──┘             │               │
                               │               │
                             ┌─┤               ├─┐
                             │N│               │N│ -- Children Node
                             └─┘               └─┘
      From a tree perspective, a set can be represented in a matrix, where you have multiple Nodes - that has a parent 
      We call that parent through some action

      Take that matrix above - where if your initial Node was to go left from node % the path cost would be 4


   **** How do you create this ? 
        Implemention needs one to create a /Expand/ Function, that creates new nodes filling various fields and ussing a SuccesorFn of the problem to create
        the corresponding states -> Easily done in prolog

  *** The algorithm 
      @code python
        def TreeSearch(Problem, Statergy) -> solution or failure: 
          # -- Initalise search with problem as the root node
          x = RootNode
          front = list() # Some sort of list - datastructure 

          While True:
            if tree[0] is None:
                return False
            # choose and remove a lead node L from the front {depends on stratergy}
            L = front.remove("Depends on stratergy")
            if L is in Goal_State :
              return solution
            else:
              x = expand(L)
              front.append(x)
              # Expand L and adding it to the resulting nodes to the frntier
      @end

   **** Whats going on here
        
        This algorithm listed above is the base algorithm between all the searches that are listed above 
        1. DFS
        2. BFS 
        3. Depth Deepning Search
        4. Iterative Deepening Search 

        - Initalise a search tree with an initial state - So for example when you are passing a root node 

        - The front list will contain the other list nodes avaliable at any given time, for expansion for any given time. 
        -- Meaning this can be used to expand the search tree

        - If you dont have any nodes within the front list, that would mean that you have explored all the possible
          nodes within that given datastructure




        

        



* Developers Note
  - _Create a search Tree based on notes_

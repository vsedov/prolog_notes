%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Define Article %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Using Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{empheq}
\usepackage{mdframed}
\usepackage{booktabs}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{color}
\usepackage{psfrag}
\usepackage{pgfplots}
\usepackage{bm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Other Settings

%%%%%%%%%%%%%%%%%%%%%%%%%% Page Setting %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\geometry{a4paper}

%%%%%%%%%%%%%%%%%%%%%%%%%% Define some useful colors %%%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{ocre}{RGB}{243,102,25}
\definecolor{mygray}{RGB}{243,243,244}
\definecolor{deepGreen}{RGB}{26,111,0}
\definecolor{shallowGreen}{RGB}{235,255,255}
\definecolor{deepBlue}{RGB}{61,124,222}
\definecolor{shallowBlue}{RGB}{235,249,255}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%% Define an orangebox command %%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\orangebox[1]{\fcolorbox{ocre}{mygray}{\hspace{1em}#1\hspace{1em}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%% English Environments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheoremstyle{mytheoremstyle}{3pt}{3pt}{\normalfont}{0cm}{\rmfamily\bfseries}{}{1em}{{\color{black}\thmname{#1}~\thmnumber{#2}}\thmnote{,--,#3}}
\newtheoremstyle{myproblemstyle}{3pt}{3pt}{\normalfont}{0cm}{\rmfamily\bfseries}{}{1em}{{\color{black}\thmname{#1}~\thmnumber{#2}}\thmnote{,--,#3}}
\theoremstyle{mytheoremstyle}
\newmdtheoremenv[linewidth=1pt,backgroundcolor=shallowGreen,linecolor=deepGreen,leftmargin=0pt,innerleftmargin=20pt,innerrightmargin=20pt,]{theorem}{Theorem}[section]
\theoremstyle{mytheoremstyle}
\newmdtheoremenv[linewidth=1pt,backgroundcolor=shallowBlue,linecolor=deepBlue,leftmargin=0pt,innerleftmargin=20pt,innerrightmargin=20pt,]{definition}{Definition}[section]
\theoremstyle{myproblemstyle}
\newmdtheoremenv[linecolor=black,leftmargin=0pt,innerleftmargin=10pt,innerrightmargin=10pt,]{problem}{Problem}[section]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Plotting Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepgfplotslibrary{colorbrewer}
\pgfplotsset{width=8cm,compat=1.9}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}




\title{
	Propositional_logic
}
\author{
	Viv Sedov --- \texttt{viv.sedov@hotmail.com}
}
\maketitle

\tableofcontents

\newpage



\section{Propositional\_logic}

\subsection{Simple Operations}
When covering this : there are simple operations that you should know about :

Simple Operation Not:

\[\begin{array}{c | c}
    p & \neg p \\
    \hline
    1 & 0 \\
    0 & 1
\end{array}
\]

Such that in this case it is the opposite given value $\neg p $ would be the direct opposite of the given Value of P .

For example say that you have the following

\[\begin{array}{c c | c}
    p & q & p \land q\\
    \hline
    1  & 1 & 1 \\
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 0
\end{array}\]
In this example, we are stating the following command : $\neg(14 > 6)$ is false , we create this truth table to prove if that is true or not .

$P \land Q $ is true $\iff$ p and q are true

Simple $\lor$ - OR


\[\begin{array}{c c | c}
    p & q & p \lor q \\
    \hline
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    0 & 1 & 1 \\
    0 & 0 & 0 \\
\end{array}\]

In this example above , for this to hold true, atleast one of the values would have to have a one it to hold true, this is known as an \textit{Inclusive} or as in you can say the following and it would make sense:
\textbf{I will go to the shops $\lor$ i will go to the coast}\\

\\

Simple Operation $\implies$
This is where if something is true the other must be true , or where you given an equivalent pointer to if p then q


\[\begin{array}{ c c | c }
    p & q & p \implies q \\
    \hline
    1 & 1 & 1 \\
    1 & 0 & 0 \\
    0 & 1 & 1 \\
    1 & 1 & 1 \\
\end{array}\]


With the above example this is not cause and effect , there is a reason for why this occours , and that is that there is a pointer such that it acts like an if statment, with the following code shown below :

\begin{lstlisting}
foo = True
if foo:
    return 1
else:
    return 0
\end{lstlisting}

The code above is rather simple , but shows that if something is true , then you would have some sort of value expression , or some pointer that would return if it is correct or not .

In the weird scenario of f and t , where if f is false it implies that q is true , that is because  the q value is true , meaning that it would hold , a little trick for this one is that for what ever the second value is , if it is true , it will hold , if both are false , then it will true , though if one is true and the other is false , it will not hold .\\

Logically equivalent $\iff$ this can also be seen as if and only if or iff \\
Here is an example of the logical truth table behind this
\[\begin{array}{c c | c }
    p & q & p \iff q \\
    \hline
    1 & 1 & 1 \\
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
\end{array}\]

With this , Where if something is true then the other must be true or if its false then the other would have to be false , in this case you are seeing if these two values are the same .

Example Exersises of how this would all work :
\\
Given that :
\[p = Logic is fun for jane \\ \\
q = david does not like cabbage \\ \\
r = david eyes are blue \]\\

We can then further express all of this in a notational form .
\begin{itemize}
    \item $\neg p \land q$
        This would imply the following truth table
        \[\begin{array}{c c c | c }
            \neg p & p & q & \neg p \land q \\
            \hline
              0 & 1 & 1 & 0 \\
              1 & 0 & 1 & 1 \\
              0 & 1 & 0 & 0 \\
              1 & 0 & 0 & 0
        \end{array}\]
    \item $\neg R \land \neg P \implies$  Both are not goint to be true such that you would get only one possible answer for this  .
\end{itemize}


Multiple truth table example :
show the following in a truth table :
\\
\[p \land (q \implies r) \]

\[\begin{array}{c c c | c | c }
    p & q & r & q \implies r & p \land (q \implies r) \\
    \hline
    1 & 1 & 1 & 1 & 1 \\
    1 & 1 & 0 & 0 & 0\\
    1 & 0 & 1 & 1 & 1\\
    0 & 1 & 0 & 0 & 0\\
    0 & 1 & 1 & 1 & 0\\
    0 & 0 & 0 & 1 & 0\\

\end{array}\]

Here is another example to understand how these tables would all work together
\\
\[(p \implies q) \land (q \implies p)\]
\[\begin{array}{c c c | c | c}
    p & q & q \implies p & p \implies q & (p \implies q) \land (q \implies p)\\
    \hline
    1 &  1 & 1 & 1 & 1 \\
    0 &  1 & 0 & 1 & 0 \\
    1 &  0 & 1 & 0 & 1 \\
    0 &  0 & 1 & 1 & 1 \\
\end{array}\] \\

\\ \\


\begin{definition}
 Two propositions are equal if they have the same truth values , they are known as $ P \implies Q$ this is known as logically equivalent
\end{definition}

\begin{definition}
A proposition is tautology if it is always true an example of this is $ P \lor \neg P$ this is always true

\end{definition}

\begin{definition}
A proposition is a contradiction if it is always false for example $ P \land \neg P $ this is always false
\end{definition}

\begin{definition}
A proposition is \textbf{Contingent} if it is neither Always true or false
\end{definition}

\\
\section{Disjunctive Normal Form}
A given formula is said to be a \textit{Disjunctive normal form} when it is an Or $\implies \lor$ this is known as \textbf{DNF} a function is conjunctive when it has an $ \land $ form , within their proposition logic .

\[(p \land \neg q \land r) \lor (\neg q \land \neg r) \lor q \]

Everytime a given formula is built , we would folow the rules of propositional calculus , and how for each conjunctive formula there should be a disjunctive formula as well .

\subsection{DNF of mini terms for truth tables}
\begin{itemize}
    \item For each row whose truth value is true , write doen for each of the prposition variables , of $ p_i $ in the formula of it self , either $P_i$ is true in row or $\neg P_i$ if false.
    \item Repeate the first pointer , for the truth table where the formula is true and write down the dijunction of the conjuctions .
\end{itemize}

What you will rsee is that those two values will equal up such that the result of the formula in DNF is the equivalent to the original formula .

\section{Conjunctive Normal Form}
A formula is said to be \textbf{Conjunctive Normal Form} when its conjunction is $ \land $ of disjunctive of $ \lor $ an example of this is shown below :
\[(\neg P \lor Q \lor R \lor \neg S) \land (P \lor Q) \land \neg S \land (Q \lor \neg R \lor S)\]

Every expression built up according to the rules of calc , and suchj that for each conjunctive formula there is a similar or an equivelent formual that can be written in disjunctive form .

\paragraph{Summary}
\item Conjunctive form , or in brackets , and on the outside
\item Disjunctive form,  And in the brackets and or on the outside
\newpage
\section{Logical Equivalences}
We can use this to obtain normal form , when we use the implication law to eliminate subproccess - when ever you have a doubel negation and demorgans to bring a $ \neg $ you what this value to be on the outside  : here are the sub process of how this can be done :


\[\neg\neg P \iff P \]
This rule is the double negation Law \\ \\

\[ \begin{array}{c}
    (P \lor Q) \iff (Q \lor P) \\
    (P \land Q) \iff (Q \land P) \\
    (P \iff Q) \iff (Q \iff P)
\end{array}\]
Commutaive laws where both values would have to equal towards each other  .


\[\begin{array}{c}
    ((P \lor Q) \lor R) \iff (P \lor (Q \lor R))\\
    ((P \land Q) \land R) \iff (P \land(Q \land R)) \\
\end{array}\]
This is the associative laws , where it is very similar to how they work in matricies in which they can equate towards each other . \\

\[\begin{array}{c}
    ((P \lor Q) \land R) \iff (P \lor (Q \land R))\\
    ((P \land Q) \lor R) \iff (P \land(Q \lor R)) \\
\end{array}\]
This lase is the distributive law , in which the given values would be changed within a DNF and CNF representation

\[\begin{array}{c}
    (P \lor P) \iff P \\
    (P \land P) \iff P
\end{array}\]
Idempotent laws where the values of it self would always equal to it self no matter what .

\item Demorgans Law :

\[\begin{array}{c}
    \neg(P \lor Q) \iff (\neg P \land \neg Q)\\
    \neg(P \land Q) \iff (\neg P \lor \neg Q)\\
    (P \land Q) \iff \neg(\neg P \lor \neg Q)\\
    (P \lor Q) \iff \neg(\neg P \land \neg Q)\\
\end{array}\]
Most times when you lookat demorgans law , you will notice that its very similar to the laws that have been stated above, but the thing that you want to note is that you will see that they are equal in some sense ,  where an or , is a direct link with Not  and And it self.


\item $\S$ Contrapositive Laws
    \[\begin{array}{c}
    (P \implies Q) \iff (\neg Q \implies \neg P)
    \end{array} \]

    implication that imply towards each other are contrapositive and hence you can switch out the given details of that infomation .

    where If Q is an active reciever then P must be an active pointer is the same as stating if not p equates to Not q, in some sense you should understand how that would work .

\item $\S$  Implication
\[\begin{array}{c}
    (P \implies Q) \iff (\neg P \lor Q)\\
    (P \implies Q) \iff \neg(P \land \neg Q)
\end{array}\]

\item  $\S$ Furhter implication
\[\begin{array}{c}
    (P \lor Q) \iff (\neg P \implies Q) \\
    (P \land Q) \iff \neg(\neg p \implies \neg Q)
\end{array}\]
Thi sone is rather annyoing , but the principle of how this works is very intriguing , if you do prove this via proof table you will see that they are truly equivalent:
$P \lor Q$

\[\begin{array}{c c | c}
    p & q & p \lor q \\
    \hline
    1 & 1 & 1 \\
    1 & 0 & 1 \\
    0 & 1 & 1 \\
    0 & 0 & 0 \\
\end{array}\]



this is the same as :
$(\neg P \implies Q) $


\[\begin{array}{c c c | c}
    P & Q & p \implies Q & (\neg P \implies Q)\\
    \hline
    1 & 1 & 1 & 1 \\
    0 & 1 & 1 & 1 \\
    1 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0 \\

\end{array}\]

If you look at the given tables above you will notice that indeed they are the same, a truth tabel may be long but they are very good at breaking down the given data that you have into something more readble .


\item Further Implies and equivalences

\[\begin{array}{c}
    ((P \implies R) \land (Q \implies R)) \iff ((P \lor Q) \implies R)\\
    ((P \implies Q) \land (P \implies R)) \iff ((P \implies (Q \land R)) \\
\end{array}\]
With this law you are using the given equivelences that are shown above with the disjunctive and conjunctive views ,but within an equivelence ratio


\item  $\S$ Exportion Law
\[\begin{array}{c}
    ((P \land Q) \implies R) \iff (P \implies (Q \implies R))
\end{array}\]

This one is a good one , Mainly because if anything that does imply to another pointer , you can show that they are all equal towards each other .



\item $\S$ Side Notes
    Within the compound proposition $\neg(P \lor Q) \&  (\neg P \land \neg Q) $ they are the same , hence why when you look at the proof that is shown above you will see that they are the same .

When ever you look at equivelences you will notice that connectives $ \lor \land $ will allways suggest that $ P \lor Q \implies Q \lor P $

\newpage

\section{Formal definition }

\begin{definition}[Valid]
    An argument would be considered valid if and only if it takes a form that makes it impossible fro the premise to be true, in the sense that the conclusion is never going to be false. it is not possible to show it to be false in some sense.
        A formula is valid if and only if it is true under every understanding of its given argument, or its given schema, we can say it is valid if true holds for everything..
\end{definition}

\begin{definition}[Sound implies Valid]
    Valid allows us to imply Soundness

    We can say that if you have a valid argument, then you also have a sound statement.
    am argument would be considered sound if it is valid and all the premise is true.
\end{definition}

\begin{definition}
    Sound, in logic a premise or conclusion is said to be valid if it is true under every possible understanding of its given argument, or its given schema.
        \begin{center}
          \begin{tabular}{ c c c }
            1 & 2 & 1 \\
            \hline
            24 & 5 & 1  \\
            \hline
            7 & 8 & 1
          \end{tabular}
        \end{center}

        The example their would be both valid and sound
        \begin{math}
            \forall axiom \exists axiom \implies \vdash A
        \end{math}
        What this just means is that A consist of either an axiom or can get derived from an axiom set using only the rules of inference

        \textbf{\textit{To Dumb this down even more, if you have statement x and you want to prove statement y, you can only do so by breaking x down into smaller statements to see if you can prove and show that y exists}}
        \\
        \begin{math}
            \forall x \exists y \implies \vdash y  \\
            \forall x \exists y \implies \vdash x \land y \\
            \forall x \exists y \implies \vdash x \lor y \\
            \forall x \exists y \implies \vdash x \implies y \\
            \forall x \exists y \implies \vdash x \iff y \\
            \forall x \exists y \implies \vdash x \leftarrow y \\
            \forall x \exists y \implies \vdash x \rightarrow y \\
            \forall x \exists y \implies \vdash x \leftrightarrow y \\
        \end{math}

        Thing to note is that it does \textit{Not} mean that \textbf{A is satisfied} this is a deduction but if you want to show satisfaction you would have to show

        \begin{math}
            A \ \ indicates \ \ \forall Axiom A \\
            \forall A A(\models A) \implies True
        \end{math}

\end{definition}

\begin{theorem}[Validity of statement]
    Validity says nothing about whether or not any statement of the premises is true or not, it only says that the conclusion is true under every possible understanding of the premises.
    the key work their is Understanding of its own premises .

    Such that validity states that its more about the form of an argument than it being true of it self.
\end{theorem}

So we can say a argument is valid if it has the proper form . An argument can have the right form, but be false.
\\
\begin{tt}
Daffy Duck is a duck \\
All ducks are insects \\
their for daffy duck is a insect \\
\end{tt}

Notice how these argument contain a form for \textit{if x is Y} but then you see that they are not true.
Notice However that if the premises \textbf{Were} True then the conclusion would also have to be true - this is a valid proof for validity. A valid argument needs not have true premises or a true conclusion.

\begin{theorem}[Sound requires a true premises]
    Sound logically implies that a statement is true, this is due to the fact that, when a statement is sound, it means that it has a true premises and a true conclusion, we can formally derive x from y using this factor.

    \textbf{\textit{Soundness}} Is an argument or a factor if it means the following arguments

    \begin{itemize}
        \item It is valid
        \item it has a true premises
    \end{itemize}
\end{theorem}

\begin{enumerate}
  \item  Sound requires both valid and to have a true premisies
  \item for all valid arguments if the premises are true then the conlusion must also be true
\end{enumerate}

Example :

\begin{enumerate}
    \item All rabits are mammals
    \item bugs bunny is a rabbit
    \item Therfore, Bugs bunny is a mammal
\end{enumerate}
In this argument we state that all of the premises are true, then the conclusion is true, so it is valid, and the premises are true, all rabbitss in fact are mammals and bugs bunny is a rabitt - so our conclusion makes sense.

\begin{definition}
    Completeness
    \begin{displaymath}
        \alpha \models \beta \implies \alpha \vdash \beta
    \end{displaymath}
    i.e if we can show something is true, then we can say that it is provable - we want to be able to prove all true statements, but you can also get false statements - such that you can prove both false and true Statements, such that if you end up proving false then your statement is no longer sound.
\end{definition}
\newpage

\begin{definition}
    Soundness
    \begin{displaymath}
        \alpha \vdash \beta \implies \alpha \models \beta
    \end{displaymath}
    If we have a formulation i.e xy = 10, then we want to be able to show that fact. We do not want a system where we start out with something true and dedice something to be false, if we know something we should prove with our current knoweldge of breaking something down, that given statement would hold, through infierence rules.

    However it is conceivable that even if our system is sound, it maybe incomplete, regarding what it can express hence why it requires to have a competes property to ensure that our given formulation of our proof would hold true.


\end{definition}


\subsection{Summary without the crap }
If your KB \textit{Knowledge base }Entails Q then all interpretations ( assigning true or false ) values to variables that would allow you to evaluate your knowledge to True, also evaluates to Q to true
\begin{math}
    KB \models Q
\end{math}
\item Entailment refers to how premises lead to a conclusion
reacall how m(b) is a subset of m(a)

\begin{align}

    \includegraphics[width=200px]{../img/2022-03-18-16-26-04.png}
\end{align}
Leads into

\begin{align}
    \includegraphics[width=200px]{../img/proofOfModel.png}
\end{align}

Inference is a procedure for deriving a new sentence ‘p’ from ‘KB’ following some algorithm.
\begin{math}
    KB \vdash p
\end{math}
The inference algorithm is sound if it derives only sentences that are entailed by KB. The inference algorithm is complete if whatever can be entailed by KB can also be inferred from KB.
Basically, an inference is an informal and less reliable kind of entailment.

\begin{itemize}
    \item We have a kb
    \item We have some sentence S - query
    \item we want to prove S from our KB
    \item We say it is sound and complete if the space of model is finite within 2 pow n
\end{itemize}

\begin{align*}
    \includegraphics[width=200px]{../img/2022-03-18-16-45-07.png}
\end{align*}

\section{Resolution algorithm}
\begin{itemize}
    \item input Kb and S
    \item Output true if
          $KB \models S$ False otherwise
    \item  Initalise a list of clauses  CNF(KB and not S)
        \begin{itemize}
            \item for each pair of clauses C i and c h
            \item R implies resolution of i and j
            \item new resolution is made
        \end{itemize}
    \item If clauses are new then return false
    \item if cluauses unifie each other return true
\end{itemize}

\newpage
\subsection{Resolution properties}
\begin{itemize}

    \item Resolution is Sound i.e it produces a sentence that are entailed by their orginal owner
    \item Resolution is complete - it is guarantee to establish entailment of the query for every finite time
    \item Completeness is based on the key theorem
        \begin{theorem}
            If a set of clauses is unsatisfiable, then the set of all clauses that can be obtained by the resolution contains an empty clause
        \end{theorem}
    \item So in short, we can say the opposite of a resolute theorem is that if we cannot find the empty clause the query must be satisfiable.
\end{itemize}

We use resolution to check consistency of how KB holds
\begin{math}
    Human \implies Mortal\\
    Peter \implies Human
\end{math}
We convert that into CNF
\begin{math}
    \neg Human \lor Mortal\\
    \neg Peter \lor Human \\
\end{math}
We can then give our resolution to this being
\begin{math}
    \neg Peter \lor Mortal
\end{math}

\begin{align}
    \includegraphics[width=200px]{../img/2022-03-18-17-42-10.png}
\end{align}
Here in this image you can see how we can go from one proof, after another by linking them, to return if a valid argument will be true or false.

\subsection{Horn Form KB}
Horn Form is a clause or a form in which a logical inference problem is given :

Given : \\
\begin{itemize}
    \item A KB is a set of information
    \item A sentance $\alpha \implies theorem $
\end{itemize}

If a sentence is in KB, are restricted to some special form, some of the sound inference rules might be complete . In short its being able to convert from CNF form into implication rules
\\
\begin{math}
    (\alpha \lor \neg \beta) \land (\neg \alpha \lor \neg \gamma \lor \delta ) \\
    \iff \\
    (\beta \implies \alpha ) \land (\alpha \implies \gamma) \implies \delta)
\end{math}
This is known as horn form normal form.

\begin{itemize}
    \item Two inference rules that are sound and complete with respect to properistional symbols for kb in the hron normal form
        \begin{itemize}
            \item resolution on a positive unit
            \item Modus pones
        \end{itemize}
\end{itemize}



\section{Chaining}





\end{document}
